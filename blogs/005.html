<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>generating sine waves using golang</title>
    <meta name="description" content="generating sine waves using golang" />
    <meta
      name="keywords"
      content="programming, go, golang, audio programming, from scratch, computer science"
    />
    <meta name="author" content="0xmukesh" />

    <link rel="stylesheet" href="/styles.css" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  </head>
  <body class="blog">
    <h1>generating sine waves using golang</h1>
    <p class="blog__byline">
      by <a href="/">mukesh</a> on
      <time datetime="2024-12-28">28th December 2024</time>
    </p>

    <p>
      while scrolling through youtube, i came across this video on my feed by
      <a href="https://www.youtube.com/@javidx9">javidx9</a> -
      <a href="https://youtu.be/tgamhuQnOkM?si=QnRopBay40F54sAH"
        >https://youtu.be/tgamhuQnOkM?si=QnRopBay40F54sAH</a
      >
      about building a sound synthesizer in c++, so i thought of giving audio
      programming a shot. in this blog post, we'll cover few of the basic topics
      and build a simple program which would generate a sine wave of a certain
      frequency and save it to a <code>.wave</code> file, amplify and peform
      stereopanning on a given <code>.wave</code> file.
    </p>

    <h2>what is sound?</h2>

    <p>
      sound is a phenomenon caused by vibration in particles that propagates as
      a wave through a transmission medium such as air, water, or solids. most
      of the sounds in the real world propagate in the form of a sine wave (or
      combination of different sine waves).
    </p>

    <p>
      for example, the note A above middle C on the piano propagates as a
      (almost) pure sine wave with a frequency of 440Hz (<a
        href="https://www.reddit.com/r/AskPhysics/comments/10tffnh/how_can_a_piano_key_have_only_one_frequency/"
        >ref: how can a piano key only have one frequency?</a
      >) and it can be mathematically represented as follows:
    </p>

    <blockquote>y = sin(880&pi;x)</blockquote>

    <h2>what is audio?</h2>

    <p>
      sound is a mechanical wave energy, while audio is the electrical
      representation of that sound wave.
    </p>

    <p>
      a microphone converts the mechanical sound waves into analog signals which
      is later passed through an analog-digital converter (ADC) which converts
      these analog signals into digital signals, which would be understood by a
      computer.
    </p>

    <p>
      there are two important keywords in the context of digital audio -
      <b>bit rate</b> and <b>sample frequency</b>
    </p>

    <p>
      the analog signals hold information about various wave characteristics at
      that particular instant such as the amplitude. sample frequency is the
      number of times a
      <i>snapshot</i> of these characteristics is taken and these snapshots are
      later used to re-create the sound wave.
    </p>

    <p>
      most of the audio which is delivered nowadays either uses 44.1 kHz or 48
      kHz as the sample frequency. the frequency limit of humans range from 20
      Hz to 22 kHz. nyquist rate is the minimum sampling rate needed to
      accurately represent a signal and it is twice the highest frequency of the
      signal.
    </p>

    <blockquote>44100 = 2 * 22000 + 100</blockquote>

    <p>
      why isn't it 44 kHz? well, an additional 100 Hz sorta acts like a
      transition band or room for error, which prevents unwanted distortion in
      the higher frequencies.
    </p>

    <p>
      in the early days, digital audio was stored on modified video recorders
      and 44.1 kHz worked perfectly with the video equipment at that time and it
      became the industry standard.
    </p>

    <p>
      bit depth is related to the precision of each <i>snapshot</i>. if the bit
      depth is 16 then the maximum number which could be represented is +32767
      (((2^16 - 1) - 1)/2) and the least is -32767. a snapshot could either have
      +ve or -ve amplitude. so in simple words - the higher the bit depth, the
      more clearly it is represented digitally, at the regions with really high
      or really low frequencies.
    </p>

    <h2>crafting initial sounds</h2>

    <p>let's a simple program which would generate a sine wave of 440 Hz.</p>

    <pre><code class="language-go">package main

import (
  "encoding/binary"
  "fmt"
  "math"
  "os"
  "time"
)

const (
  duration   = 5
  sampleRate = 44100
  freq       = 440
)

func main() {
  ns := duration * sampleRate
  angle := (math.Pi * 2.0) / float64(ns)

  f, err := os.Create("wave.bin")
  if err != nil {
    panic(err.Error())
  }
  start := time.Now()

  for i := 0; i < ns; i++ {
    sample := math.Sin(angle * freq * float64(i))
    var buf [4]byte

    binary.LittleEndian.PutUint32(buf[:], math.Float32bits(float32(sample)))

    if _, err := f.Write(buf[:]); err != nil {
      panic(err.Error())
    }
  }

  fmt.Printf("done - %dms\n", time.Since(start).Milliseconds())
}</code></pre>

    <p>
      the above program generates a <code>.bin</code> file containing binary
      representation of samples of a sine wave of 400 Hz frequency, at a sample
      rate of 44.1 kHz.
    </p>

    <blockquote>y = sin(440x)</blockquote>

    <p>
      as sample rate is number of samples taken per second, number of samples
      can be found out with the help of duration and sample rate:
    </p>

    <blockquote>number of samples = (sample rate) * (duration)</blockquote>

    <p><code>angle</code> is the angular increment per sample.</p>

    <p>
      <code>sample</code> is snapshot of the wave characteristics at that
      moment, in this case it is the amplitude i.e. value of the function at
      that point.
    </p>

    <p>
      and the floating point sample is converted to its corresponding
      little-endian byte representation and written to <code>wave.bin</code>.
      i'm converting it to little-endian as the CPU of my laptop (intel i5) uses
      little-endian. check which byte representation your machine's CPU follows
      via the following command:
    </p>

    <pre><code class="language-bash">lscpu | grep "Byte Order"</code></pre>

    <p>to play the audio, we can use <code>ffplay</code></p>

    <blockquote>ffplay -f f32le -ar 44100 -showmode 1 wave.bin</blockquote>

    <ol>
      <li>
        <code>-f</code> specifies the file format. <code>f32le</code> indicates
        that the audio is encoded in 32-bit litte-endian byte format.
      </li>

      <li>
        <code>-ar</code> specifies the audio sample rate, which is 44.1 kHz in
        this case.
      </li>

      <li>
        <code>-showmode 1</code> opens a GUI showing the sine wave re-created
        from the samples.
      </li>

      <p>
        on running the above <code>ffplay</code> command, you would a sound
        something similar to -
        <a href="https://files.catbox.moe/b8n1k9.mp4"
          >https://files.catbox.moe/b8n1k9.mp4</a
        >
      </p>
    </ol>

    <h2>adding exponential decay</h2>

    <p>
      let's add some exponential decay so that the sound slowly fades off
      instead of abruptly ending.
    </p>

    <pre><code class="language-go">startAmplitude := 1.0
endAmplitude := 1.0e-4
decayFactor := math.Pow(endAmplitude/startAmplitude, 1.0/float64(ns))
// ...

for i := 0; i < ns; i++ {
  sample := math.Sin(angle * freq * float64(i))
  sample *= startAmplitude
  startAmplitude *= decayFactor

  var buf [4]byte

  binary.LittleEndian.PutUint32(buf[:], math.Float32bits(float32(sample)))

  if _, err := f.Write(buf[:]); err != nil {
    panic(err.Error())
  }
}
</code></pre>

    <p>
      on running the script, you should notice that the audio fades off that the
      end -
      <a href="https://files.catbox.moe/lcls0l.mp4"
        >https://files.catbox.moe/lcls0l.mp4</a
      >
    </p>

    <h2>understanding wave file format</h2>

    <p>
      we've generated the byte code that can produce some sound, let's save it
      into a <code>wave</code> file, so it can be played by the media players
      rather than using <code>ffplay</code>
    </p>

    <p>
      waveform audio file format or wave in short stores audio data as samples,
      along with some metadata such as number of audio channels (mono, stereo,
      etc.). a wave file is usually encoded using
      <a
        href="https://www.sciencedirect.com/topics/engineering/pulse-code-modulation"
        >pulse code modulation</a
      >, it isn't required to know about PCM to understand this blog post.
    </p>

    <p>
      a wave file follows a strict format and is majorly split into three
      <i>blocks</i> of data.
    </p>

    <ol>
      <li>header</li>
      <li>fmt - holds the related metadata</li>
      <li>raw data</li>
    </ol>

    <hr />

    <p>
      the structure of the header is as follows: (on the left side, byte offsets
      are mentioned and on the right side, the corresponding stored data's
      label)
    </p>

    <ol>
      <li>
        0 - 4 bytes - chunk id (must be equal to <code>RIFF</code>, written in
        little-endian. if it was written in big-endian, then it would be have
        been <code>RIFX</code>)
      </li>

      <li>4 - 8 bytes - chunk size</li>

      <li>8 - 12 bytes - format (must be equal to <code>WAVE</code>)</li>
    </ol>

    <hr />

    <p>the structure of the "fmt" block is as follows:</p>

    <ol>
      <li>12 - 16 - sub chunk 1 id (must be equal to <code>fmt </code>)</li>

      <li>16 - 20 - sub chunk 1 size</li>

      <li>
        20 - 22 - audio format (equal to <code>1</code>, if it is encoded via
        pulse code modulation)
      </li>

      <li>22 - 24 - number of audio channels (1 for mono, 2 for stereo)</li>

      <li>24 - 28 - sample rate (i.e. sample frequency)</li>

      <li>
        28 - 32 - byte rate (byte rate = (sample rate) * (number of audio
        channels) * (bits per sample) / 8)
      </li>

      <li>
        32 - 34 - block align (block align = (number of audio channels) * (bits
        per sample) / 8)
      </li>

      <li>34 - 36 - bits per sample (i.e. bit depth)</li>
    </ol>

    <hr />

    <p>the structure of the data block is as follows:</p>

    <ol>
      <li>36 - 40 - sub chunk 2 id (must be equal to <code>data</code>)</li>

      <li>40 - 44 - sub chunk 2 size</li>

      <li>44 - ... - raw samples</li>
    </ol>

    <hr />

    <p>
      here is a better pictorial representation of the structure -
      <a
        href="https://web.archive.org/web/20141213140451/https://ccrma.stanford.edu/courses/422/projects/WaveFormat/"
        >https://ccrma.stanford.edu/courses/422/projects/WaveFormat/</a
      >. you can also visualize the format of a <code>wave</code> file by
      playing around with it in a hex editor like
      <a href="https://imhex.werwolv.net/">ImHex</a>
    </p>

    <h2>working with wave files</h2>

    <p>let's first structure the format in code.</p>

    <pre><code class="language-go">package types

type Sample float64

type WaveHeader struct {
  ChunkId   []byte
  ChunkSize int
}

type WaveFmt struct {
  SubChunk1Id   []byte 
  SubChunk1Size int    
  AudioFormat   int    
  NumOfChannels int    
  SampleRate    int    
  ByteRate      int    
  BlockAlign    int   
  BitsPerSample int
}</code></pre>

    <p>
      before starting to work on a wave file writer, let's make a few utility
      functions which would convert ints/floats to their equivalent byte
      representations in little-endian.
    </p>

    <pre><code class="language-go">func IntToBits(i int, size int) []byte {
  switch size {
  case 16:
    return Int16ToBits(i)
  case 32:
    return Int32ToBits(i)
  default:
    panic("invalid size. only 16 and 32 bits are accepted")
  }
}

func Int16ToBits(i int) []byte {
  b := make([]byte, 2)
  binary.LittleEndian.PutUint16(b, uint16(i))
  return b
}

func Int32ToBits(i int) []byte {
  b := make([]byte, 4)
  binary.LittleEndian.PutUint32(b, uint32(i))
  return b
}

func FloatToBits(f float64, size int) []byte {
  bits := math.Float64bits(f)
  b := make([]byte, 8)
  binary.LittleEndian.PutUint64(b, bits)

  switch size {
  case 2:
    return b[:2]
  case 4:
    return b[:4]
  }

  return b
}</code></pre>

    <p>
      and another set of utility functions which would take in
      <code>WaveHeader</code>/<code>WaveFmt</code> and return their equivalent
      byte representation.
    </p>

    <pre><code class="language-go">func WaveFmtToBits(wfmt types.WaveFmt) []byte {
  var b []byte

  b = append(b, wfmt.SubChunk1Id...)
  b = append(b, Int32ToBits(wfmt.SubChunk1Size)...)
  b = append(b, Int16ToBits(wfmt.AudioFormat)...)
  b = append(b, Int16ToBits(wfmt.NumOfChannels)...)
  b = append(b, Int32ToBits(wfmt.SampleRate)...)
  b = append(b, Int32ToBits(wfmt.ByteRate)...)
  b = append(b, Int16ToBits(wfmt.BlockAlign)...)
  b = append(b, Int16ToBits(wfmt.BitsPerSample)...)

  return b
}

func SamplesToBits(samples []types.Sample, wfmt types.WaveFmt) ([]byte, error) {
  var b []byte

  for _, s := range samples {
    var multiplier int

    switch wfmt.BitsPerSample {
    case 8:
      multiplier = math.MaxInt8
    case 16:
      multiplier = math.MaxInt16
    case 32:
      multiplier = math.MaxInt32
    case 64:
      multiplier = math.MaxInt64
    default:
      return nil, fmt.Errorf("invalid size - %d, must be 8, 16, 32 or 64-bits only", wfmt.BitsPerSample)
    }

    bits := IntToBits(int(float64(s)*float64(multiplier)), wfmt.BitsPerSample)
    b = append(b, bits...)
  }

  return b, nil
}

func CreateHeaderBits(samples []types.Sample, wfmt types.WaveFmt) []byte {
  var b []byte

  chunkSizeInBits := Int32ToBits(36 + (len(samples)*wfmt.NumOfChannels*wfmt.BitsPerSample)/8)

  b = append(b, []byte(constants.WaveChunkId)...)
  b = append(b, chunkSizeInBits...)
  b = append(b, []byte(constants.WaveFileFormat)...)

  return b
}</code></pre>

    <p>
      as we have everything ready now, let's write a simple struct
      <code>WaveWriter</code> which saves the samples into a wave file.
    </p>

    <pre><code class="language-go">package helpers

import (
  "os"

  "github.com/0xmukesh/sound-synthesizer/constants"
  "github.com/0xmukesh/sound-synthesizer/types"
  "github.com/0xmukesh/sound-synthesizer/utils"
)

type WaveWriter struct{}

func NewWaveWriter() WaveWriter {
  return WaveWriter{}
}

func (w WaveWriter) WriteWaveFile(file string, samples []types.Sample, metadata types.WaveFmt) error {
  f, err := os.Create(file)
  if err != nil {
    return err
  }
  defer f.Close()

  var data []byte

  headerBits := utils.CreateHeaderBits(samples, metadata)
  data = append(data, headerBits...)

  wfmtInBits := utils.WaveFmtToBits(metadata)
  data = append(data, wfmtInBits...)

  data = append(data, []byte(constants.WaveSubChunk2Id)...)
  data = append(data, utils.Int32ToBits(len(samples)*metadata.NumOfChannels*metadata.BitsPerSample/8)...)

  samplesBits, err := utils.SamplesToBits(samples, metadata)
  if err != nil {
    return err
  }
  data = append(data, samplesBits...)

  if _, err := f.Write(data); err != nil {
    return err
  }

  return nil
}</code></pre>

    <p>
      the header is created using the above utility functions and also the
      metadata and samples are converted to their equivalent byte
      representations using the above utility functions.
    </p>

    <p>
      let's using the <code>WriteWaveFile</code> method in our script to save
      the samples into a <code>wave</code> file.
    </p>

    <pre><code class="language-go">var samples []types.Sample

for i := 0; i < ns; i++ {
  sample := types.Sample(math.Sin(angle*freq*float64(i)) * startAmplitude)
  startAmplitude *= decayFactor

  samples = append(samples, sample)
}

waveWriter := helpers.NewWaveWriter()
if err := waveWriter.WriteWaveFile("test.wav", samples, wavefmt); err != nil {
  panic(err.Error())
}</code></pre>

    <p>
      and on running the script, a new file named <code>test.wav</code> must be
      created, which must sound similar to -
      <a href="https://files.catbox.moe/bq0vik.wav">test.wav</a>
    </p>

    <footer style="text-align: center; margin-top: 32px">
      <a href="/">0xmukesh</a>
    </footer>

    <script src="/js/blogs/add-top-nav.js"></script>
    <script>
      hljs.highlightAll();
    </script>
  </body>
</html>
